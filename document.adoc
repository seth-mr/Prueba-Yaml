= DOCUMENTO DE PRUEBAS



== LOGIC

=== ChatRepositoryTests

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-CR-01
| SaveMessage_ValidMessage_AddsMessage
| username = "seth", idDestino = 99, texto = "Hola mundo"
| usuarios contiene un usuario con id=5 y perfil username="seth". +
mensajes está vacío. +
mockDb.usuarios y mockDb.mensajes devuelven estas listas.
| Se valida que: existe 1 documento, y los atributos del mensaje son correctos
| Éxito: el mensaje se agrega correctamente

| TC-CR-02
| SaveMessage_ValidMessage_CallsSaveChangesOnce
| username = "seth", idDestino = 3, texto = "mensaje"
| usuarios contiene un usuario con id=10. +
mensajes está vacío. +
mockDb.SaveChanges() está marcado como Verifiable.
| Se verifica: +
 SaveChanges() se llamó exactamente una vez.
| Éxito: la operación guarda cambios en BD.

| TC-CR-03
| SaveMessage_EmptyUsername_ThrowsArgumentException
| username = "", idDestino = 2, texto = "Hola"
| mensajes lista vacía. +
Instancia real de ChatRepository, BD simulada.
| Se lanza ArgumentException al intentar guardar mensaje con username vacío.
| Excepción controlada: datos inválidos.

| TC-CR-04
| SaveMessage_UserNotFound_ThrowsInvalidOperationException
| username = "ghost", idDestino = 2, texto = "hola"
| usuarios está vacío (no existe "ghost").
| Se lanza InvalidOperationException al no encontrarse el remitente.
| Excepción controlada: usuario inexistente.

| TC-CR-05
| GetChatByUsername_EmptySender_ThrowsArgumentException
| sender = "", recipient = "dest"
| Sin BD necesaria, solo validación de parámetros.
| Se lanza ArgumentException por sender vacío.
| Excepción controlada.

| TC-CR-06
| GetChatByUsername_EmptyRecipient_ThrowsArgumentException
| sender = "sender", recipient = ""
| BD simulada contiene usuario "sender". +
mockRepo.CreateDb() devuelve este contexto.
| Se lanza ArgumentException por recipient vacío.
| Excepción controlada.

| TC-CR-07
| GetChatByUsername_SenderNotFound_ThrowsInvalidOperationException
| sender = "ghost", recipient = "dest"
| usuarios está vacío. +
mockDb.usuarios devuelve lista vacía.
| Al no encontrar sender → Se lanza InvalidOperationException.
| Excepción controlada.

| TC-CR-08
| GetChatByUsername_RecipientNotFound_ThrowsInvalidOperationException
| sender = "sender", recipient = "noExiste"
| usuarios solo contiene al sender. +
Recipient no existe.
| Se lanza InvalidOperationException.
| Excepción controlada.

| TC-CR-09
| GetChatByUsername_NoMessages_ReturnsEmptyList
| sender="sender", recipient="dest"
| BD tiene ambos usuarios. +
mensajes está vacío.
| La lista devuelta está vacía.
| Éxito: sin mensajes

| TC-CR-10
| GetChatByUsername_ReturnsMessagesOrderedAndMappedCorrectly
| sender="sender", recipient="dest"
| BD tiene ambos usuarios. +
mensajes contiene dos mensajes con fechas diferentes. +
Uno remitente sender → dest. +
Otro dest → sender.
| Se valida que: +
 Resultado tiene 2 mensajes, el orden es correcto y el contenido de estos tambien
 Mapeo correcto de remitente y destinatario por username.
| Éxito: mensajes ordenados y mapeados correctamente.

| TC-CR-11
| GetIdByUsername_NullUsername_ThrowsArgumentException
| username = null
| No requiere BD. +
Invocación directa.
| Se lanza ArgumentException.
| Excepción controlada.

| TC-CR-12
| GetIdByUsername_UserNotFound_ThrowsInvalidOperationException
| username = "ghost"
| usuarios vacíos.
| Se lanza InvalidOperationException.
| Excepción controlada.

| TC-CR-13
| GetIdByUsername_ExactMatch_ReturnsUserId
| username = "seth"
| usuarios contiene id=10 con username "seth".
| Se verifica que el ID retornado es 10.
| Éxito: coincidencia exacta encontrada.

| TC-CR-14
| GetIdByUsername_CaseInsensitiveMatch_ReturnsUserId
| username = "playerone"
| BD contiene username "PlayerOne". +
Caso insensible.
| El resultado es ID 20.
| Éxito: coincidencia sin importar mayúsculas/minúsculas.

| TC-CR-15
| GetIdByUsername_UserHasMultipleProfiles_ReturnsMatchingUserId
| username = "seth"
| Usuario id=33 con múltiples perfiles, uno de ellos "seth".
| El ID retornado es 33.
| Éxito: coincide perfil adecuado.

| TC-CR-16
| GetIdByUsername_OnlyOneUserMatches_ReturnsCorrectId
| username = "seth"
| BD contiene usuarios con perfiles distintos. +
Uno de ellos tiene username "seth".
| Retorna id=55.
| Éxito: retorna solo al usuario que coincide.
|===

=== FriendRepositoryTests

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-FR-01
| EnsureDifferentUsers_SameIds_ThrowsUserValidationError
| idUsuario1 = 5, idUsuario2 = 5
| Se obtiene por reflexión el método estático privado EnsureDifferentUsers. No hay base de datos; solo se pasan dos IDs iguales.
| Se captura la excepción producida. +
Se verifica que la excepción interna es de tipo RepositoryValidationException. +
Se verifica que el código de error es UserValidationError.
| Excepción controlada: no se permiten IDs iguales; se lanza RepositoryValidationException con código UserValidationError.

| TC-FR-02
| EnsureDifferentUsers_DifferentIds_DoesNotThrow
| idUsuario1 = 1, idUsuario2 = 2
| Se obtiene por reflexión EnsureDifferentUsers. Se invoca con dos IDs diferentes.
| Se captura cualquier excepción y se verifica que el resultado es null (no se lanza excepción).
| Éxito: el método acepta IDs diferentes sin lanzar error.

| TC-FR-03
| EnsureUsersExist_UserMissing_ThrowsUserNotFound
| idUsuario1 = 1, idUsuario2 = 99
| En la lista usuarios solo existe el usuario con id = 1. +
El contexto contiene un solo registro. +
Se invoca por reflexión EnsureUsersExist.
| Se captura la excepción producida. +
Se verifica que la excepción interna es RepositoryValidationException. +
Se verifica que el código de error es UserNotFound.
| Excepción controlada: se detecta que uno de los usuarios no existe y se lanza RepositoryValidationException con código UserNotFound.

| TC-FR-04
| EnsureUsersExist_BothExist_DoesNotThrow
| idUsuario1 = 1, idUsuario2 = 2
| La lista usuarios contiene dos usuarios con IDs 1 y 2. +
mockDb.usuarios devuelve esa lista. +
Se invoca EnsureUsersExist.
| Se verifica que no se lanza ninguna excepción (resultado de Record.Exception es null).
| Éxito: cuando ambos usuarios existen, el método no lanza errores.

| TC-FR-05
| EnsureNotFriends_AlreadyFriends_ThrowsAlreadyFriends
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades contiene un registro con (1, 2). +
  mockDb.amistades devuelve esta lista. +
  Se invoca por reflexión el método EnsureNotFriends.
| Se captura la excepción. +
  Se confirma que la excepción interna es RepositoryValidationException. +
  Se verifica que el código de error es AlreadyFriends.
| Excepción controlada: al intentar crear una amistad entre usuarios que ya son amigos, el método falla con una RepositoryValidationException con código es AlreadyFriends.


| TC-FR-06
| EnsureNotFriends_NoFriendship_DoesNotThrow
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades está vacía, por lo que no hay amistad registrada. +
mockDb.amistades devuelve una colección vacía. +
Se invoca EnsureNotFriends.
| Se valida que no se lanza ninguna excepción.
| Éxito: si no existe amistad previa, el método termina sin error.

| TC-FR-07
| EnsureFriends_NoFriendship_ThrowsFriendsLoadError
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades está vacía (no hay relación de amistad). +
Se obtiene por reflexión EnsureFriends y se invoca con el contexto y los IDs.
| Se captura la excepción interna. +
Se confirma que es RepositoryValidationException. +
Se verifica que el código es FriendsLoadError.
| Excepción controlada: el método verifica que haya amistad; al no encontrarla, lanza RepositoryValidationException con código FriendsLoadError.

| TC-FR-08
| EnsureFriends_FriendshipExists_DoesNotThrow
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades contiene un registro (1,2). +
mockDb.amistades devuelve esa lista. +
Se invoca EnsureFriends.
| Se verifica que no se lanza ninguna excepción.
| Éxito: cuando existe amistad entre los usuarios, la validación pasa correctamente.

| TC-FR-09
| EnsureNotBlocked_IsBlocked_ThrowsFriendsLoadError
| idBloqueador = 1, idBloqueado = 2
| La lista bloqueos contiene un registro con bloqueador 1 y bloqueado 2. +
mockDb.bloqueos devuelve esta colección. +
Se invoca EnsureNotBlocked.
| Se captura la excepción interna. +
Se verifica que es RepositoryValidationException. +
Se verifica que el código es FriendsLoadError.
| Excepción controlada: si el usuario ya está bloqueado, el método lanza RepositoryValidationException con código FriendsLoadError.

| TC-FR-10
| EnsureNotBlocked_NoBlock_DoesNotThrow
| idBloqueador = 1, idBloqueado = 2
| La lista bloqueos está vacía. +
mockDb.bloqueos devuelve colección sin elementos. +
Se invoca EnsureNotBlocked.
| Se verifica que no se genera ninguna excepción.
| Éxito: si no existe registro de bloqueo, la validación pasa.

| TC-FR-11
| EnsureNotBlockedSelf_SameUser_ThrowsUserValidationError
| idUsuario1 = 5, idUsuario2 = 5
| Se invoca el método privado EnsureNotBlockedSelf por reflexión con dos IDs iguales.
| Se captura la excepción. +
Se verifica que la excepción interna es RepositoryValidationException. +
Se comprueba que el código de error es UserValidationError.
| Excepción controlada: no se permite que un usuario se bloquee a sí mismo; se lanza RepositoryValidationException con código UserValidationError.

| TC-FR-12
| EnsureNotBlockedSelf_DifferentUsers_DoesNotThrow
| idUsuario1 = 1, idUsuario2 = 2
| Se invoca EnsureNotBlockedSelf con IDs distintos.
| Se verifica que no se lanza ninguna excepción.
| Éxito: la validación permite IDs diferentes.

| TC-FR-13
|EnsureNoPendingRequest_PendingRequestExists_ThrowsFriendRequestAlreadyPending
| emisor = 1, receptor = 2
| La lista solicitudes_amistad contiene una solicitud (1 → 2) con estado "pendiente". +
  mockDb.solicitudes_amistad devuelve esta lista. +
  Se invoca el método privado EnsureNoPendingRequest.
| Se captura la excepción interna. +
  Se verifica que es RepositoryValidationException. +
  Se verifica que el código es FriendRequestAlreadyPending.
| Excepción controlada: si ya existe una solicitud pendiente entre emisor y receptor, el método falla con FriendRequestAlreadyPending.


| TC-FR-14
| EnsureNoPendingRequest_NoPendingRequest_DoesNotThrow
| emisor = 1, receptor = 2
| La lista solicitudes_amistad está vacía (no hay solicitudes). +
Se invoca EnsureNoPendingRequest.
| Se verifica que no se lanza ninguna excepción.
| Éxito: si no hay solicitudes pendientes, la validación es correcta.

| TC-FR-15
| EnsurePendingRequestExists_NoPending_ThrowsFriendsLoadError
| emisor = 1, receptor = 2
| La lista solicitudes_amistad está vacía. +
Se invoca EnsurePendingRequestExists.
| Se captura la excepción interna. +
Se comprueba que es RepositoryValidationException. +
Se verifica que el código es FriendsLoadError.
| Excepción controlada: al no existir solicitud pendiente, se lanza RepositoryValidationException con código FriendsLoadError.

| TC-FR-16
| EnsurePendingRequestExists_PendingExists_DoesNotThrow
| emisor = 1, receptor = 2
| La lista solicitudes_amistad tiene una solicitud (2 → 1) con estado "pendiente". +
mockDb.solicitudes_amistad devuelve la lista. +
Se invoca EnsurePendingRequestExists.
| Se verifica que no se produce ninguna excepción.
| Éxito: si hay una solicitud pendiente entre los usuarios, la validación pasa.

| TC-FR-17
| FriendshipExists_WhenFriendshipExists_ReturnsTrue
| idUsuario1 = 1, idUsuario2 = 2
| amistades contiene un registro (1,2). +
mockDb.amistades devuelve esta lista. +
Se invoca FriendshipExists por reflexión.
| Se verifica que el resultado booleano es true.
| Éxito: el método reconoce correctamente que la amistad existe.

| TC-FR-18
| FriendshipExists_WhenFriendshipDoesNotExist_ReturnsFalse
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades está vacía. +
Se invoca FriendshipExists.
| Se verifica que el resultado es false.
| Éxito: el método indica correctamente que no hay amistad.

| TC-FR-19
| IsBlocked_WhenUserIsBlocked_ReturnsTrue
| idBloqueador = 1, idBloqueado = 2
| La lista bloqueos tiene un registro (1 bloquea a 2). +
mockDb.bloqueos devuelve esta lista. +
Se invoca IsBlocked.
| Se verifica que el resultado es true.
| Éxito: el método detecta correctamente que el usuario está bloqueado.

| TC-FR-20
| IsBlocked_WhenUserIsNotBlocked_ReturnsFalse
| idBloqueador = 1, idBloqueado = 2
| La lista bloqueos está vacía. +
Se invoca IsBlocked.
| Se verifica que el resultado es false.
| Éxito: el método indica que no hay bloqueo.

| TC-FR-21
| PendingRequestExists_WhenPendingRequestExists_ReturnsTrue
| emisor = 1, receptor = 2
| La lista solicitudes_amistad contiene una solicitud (1 → 2) con estado "pendiente". + Se invoca PendingRequestExists.
| Se verifica que el resultado es true.
| Éxito: el método detecta la existencia de la solicitud pendiente.


| TC-FR-22
| PendingRequestExists_WhenNoPendingRequest_ReturnsFalse
| emisor = 1, receptor = 2
| solicitudes_amistad está vacía. +
Se invoca PendingRequestExists.
| Se verifica que el resultado es false.
| Éxito: el método indica que no hay solicitudes pendientes.

| TC-FR-23
| MapToFriendDto_WithValidProfile_ReturnsCorrectDto
| usuario con id = 10, username = "Seth", avatar = "avatar123.png"
| Se construye una instancia de usuarios con un perfil asociado. +
Se invoca MapToFriendDto por reflexión con ese usuario.
| Se verifica que IdFriend = 10. +
Se verifica que Username = "Seth". +
Se verifica que ConnectionState es false. +
Se verifica que Avatar = "avatar123.png".
| Éxito: el mapeo del usuario con perfil a FriendDto se realiza con los valores esperados.

| TC-FR-24
| MapToFriendDto_NoProfile_ThrowsException
| usuario con id = 55 sin perfiles
| Se crea un usuario con lista de perfiles vacía. +
  Se invoca MapToFriendDto.
| Se captura la excepción producida durante la invocación del método.
| Excepción controlada el método lanza una excepción cuando se ejecuta debido a que no hay Profile.


| TC-FR-25
| GetUserIds_ValidDifferentUsers_ReturnsCorrectTuple
| receiverUsername = "Receiver", senderUsername = "Sender"
| Se simula IRepositoryUsers para que: +
GetUserIdByUsername("Receiver") devuelva 10, +
GetUserIdByUsername("Sender") devuelva 20. +
Se crea FriendRepository con ese mock.
| El método privado GetUserIds se invoca y devuelve una tupla. +
Se verifica que receiverId = 10 y senderId = 20.
| Éxito: la obtención de IDs a partir de usernames se realiza correctamente.

| TC-FR-26
| GetUserIds_SameUser_ThrowsUserValidationError
| senderUsername = "User", receiverUsername = "User"
| El mock de IRepositoryUsers devuelve siempre id = 50 para cualquier username. +
Se crea FriendRepository y se invoca GetUserIds por reflexión.
| Se espera y verifica que se lanza TargetInvocationException. +
Se comprueba que la excepción interna es RepositoryValidationException (validación de usuario).
| Excepción controlada: el método no permite que emisor y receptor sean el mismo usuario y la excepcion es del tipo RepositoryValidationException.

| TC-FR-27
| ApplyBlock_AlreadyBlocked_ThrowsException
| bloqueadorId = 1, bloqueadoId = 2
| La lista bloqueos contiene ya un registro (1 bloquea a 2). +
mockDb.bloqueos devuelve esa lista. +
Se invoca el método privado ApplyBlock.
| Se verifica que se lanza TargetInvocationException. +
Se comprueba que la excepción interna es RepositoryValidationException.
| Excepción controlada: no se permite volver a bloquear a alguien que ya está bloqueado.

| TC-FR-28
| ApplyBlock_RemovesFriendshipAndPendingRequests
| bloqueadorId = 1, bloqueadoId = 2
| amistades contiene una amistad (1,2). +
solicitudes_amistad contiene una solicitud pendiente entre 1 y 2. +
bloqueos inicialmente está vacío. +
Se invoca ApplyBlock.
| Después de la invocación: +
La lista amistades queda vacía. +
La lista solicitudes_amistad queda vacía.
| Éxito: al bloquear, se eliminan las amistades y solicitudes pendientes entre ambos usuarios.

| TC-FR-29
| ApplyBlock_AddsNewBlockEntry
| bloqueadorId = 5, bloqueadoId = 9
| amistades y solicitudes_amistad están vacías. +
bloqueos está vacío. +
Se invoca ApplyBlock.
| Se verifica que la lista bloqueos contiene exactamente 1 elemento. +
Se comprueba que el nuevo registro tiene id_bloqueador = 5 y id_bloqueado = 9.
| Éxito: se crea correctamente el registro de bloqueo entre los usuarios.

| TC-FR-30
| RemoveBlock_BlockNotFound_ThrowsException
| bloqueadorId = 1, bloqueadoId = 2
| La lista bloqueos está vacía. +
mockDb.bloqueos devuelve la lista vacía. +
Se invoca RemoveBlock.
| Se verifica que se lanza TargetInvocationException. +
La excepción interna es RepositoryValidationException.
| Excepción controlada: no se puede eliminar un bloqueo que no existe.

| TC-FR-31
| RemoveBlock_ExistingBlock_RemovesEntry
| bloqueadorId = 1, bloqueadoId = 2
| La lista bloqueos contiene un registro (1,2). +
Se invoca RemoveBlock.
| Se verifica que la lista bloqueos queda vacía tras la ejecución.
| Éxito: se elimina el registro de bloqueo existente.

| TC-FR-32
| RemoveBlock_NoMatchingBlock_ThrowsException
| bloqueadorId = 1, bloqueadoId = 2
| La lista bloqueos contiene entradas, pero ninguna con (1,2); solo (99,100) y (5,8). +
Se invoca RemoveBlock.
| Se verifica que se lanza TargetInvocationException. +
La excepción interna es RepositoryValidationException.
| Excepción controlada: si no se encuentra un bloqueo con esos IDs, el método lanza error.

| TC-FR-33
| RemoveBlock_MultipleMatchingBlocks_RemovesOnlyFirst
| bloqueadorId = 1, bloqueadoId = 2
| La lista bloqueos contiene dos registros idénticos (1,2). +
Se invoca RemoveBlock.
| Tras la ejecución, se verifica que en bloqueos queda un solo registro. +
Solo se elimina la primera coincidencia.
| Éxito: el método remueve una única entrada aunque haya duplicados.

| TC-FR-34
| RemoveFriendshipIfExists_FriendshipFound_RemovesEntry
| idUsuario1 = 1, idUsuario2 = 2
| amistades contiene una entrada (1,2). +
Se invoca RemoveFriendshipIfExists.
| Se comprueba que la lista amistades queda vacía.
| Éxito: se elimina la amistad cuando existe en el orden directo.

| TC-FR-35
| RemoveFriendshipIfExists_FriendshipFound_ReversedIds_RemovesEntry
| idUsuario1 = 1, idUsuario2 = 2
| amistades contiene una amistad (2,1). +
Se invoca RemoveFriendshipIfExists con (1,2).
| Se verifica que la lista amistades queda vacía.
| Éxito: se elimina la amistad aunque los IDs estén invertidos.

| TC-FR-36
| RemoveFriendshipIfExists_NoFriendship_NoChanges
| idUsuario1 = 1, idUsuario2 = 2
| amistades contiene una amistad entre otros usuarios (10,20). +
Se invoca RemoveFriendshipIfExists.
| Se verifica que sigue habiendo exactamente una amistad en la lista. +
No se elimina nada.
| Éxito: no se modifican entradas cuando no hay amistad entre los IDs dados.

| TC-FR-37
| RemoveFriendshipIfExists_MultipleFriendships_RemovesOnlyFirstMatch
| idUsuario1 = 1, idUsuario2 = 2
| amistades contiene dos registros (1,2) y (1,2). +
Se invoca RemoveFriendshipIfExists.
| Se verifica que queda exactamente una amistad en la lista.
| Éxito: solo se borra la primera coincidencia.

| TC-FR-38
| RemoveFriendshipIfExists_EmptyList_NoException
| idUsuario1 = 1, idUsuario2 = 2
| La lista amistades está vacía. +
Se invoca RemoveFriendshipIfExists.
| Se verifica que no se lanza ninguna excepción.
| Éxito: el método tolera listas vacías sin fallar.

| TC-FR-39
| RemovePendingRequests_ExactMatch_RemovesRequest
| emisor = 1, receptor = 2
| solicitudes_amistad contiene una solicitud (1 → 2). +
Se invoca RemovePendingRequests.
| Se verifica que la lista queda vacía.
| Éxito: se elimina la solicitud pendiente exacta.

| TC-FR-40
| RemovePendingRequests_ReversedMatch_RemovesRequest
| emisor = 1, receptor = 2
| solicitudes_amistad contiene (2 → 1). +
Se invoca RemovePendingRequests con (1,2).
| Se verifica que la lista queda vacía.
| Éxito: se elimina la solicitud aunque los IDs estén invertidos.

| TC-FR-41
| RemovePendingRequests_NoMatchingRequests_NoChanges
| emisor = 1, receptor = 2
| solicitudes_amistad contiene (5 → 7). +
Se invoca RemovePendingRequests con (1,2).
| Se verifica que la lista sigue teniendo una sola solicitud.
| Éxito: no se modifican solicitudes que no coinciden con los usuarios indicados.

| TC-FR-42
| RemovePendingRequests_MultipleMatches_RemovesAllMatches
| emisor = 1, receptor = 2
| solicitudes_amistad contiene (1 → 2) y (2 → 1). +
Se invoca RemovePendingRequests.
| Se verifica que la lista queda vacía (se eliminan ambas).
| Éxito: se eliminan todas las solicitudes relacionadas con la pareja de usuarios.

| TC-FR-43
| RemovePendingRequests_EmptyList_NoException
| emisor = 1, receptor = 2
| La lista solicitudes_amistad está vacía. +
Se invoca RemovePendingRequests.
| Se comprueba que no se lanza ninguna excepción.
| Éxito: el método es seguro ante listas vacías.

| TC-FR-44
| RemovePendingRequests_MixedRequests_RemovesOnlyThoseMatchingUsers
| emisor = 1, receptor = 2
| solicitudes_amistad contiene tres solicitudes: (1 → 2), (3 → 4) y (2 → 1). +
Se invoca RemovePendingRequests con (1,2).
| Se verifica que después de la invocación queda solo una solicitud: (3 → 4).
| Éxito: solo se eliminan las solicitudes entre los usuarios 1 y 2; el resto permanece.

| TC-FR-45
| GetFriends_NoFriendships_ReturnsEmptyList
| username = "seth"
| IRepositoryUsers.GetUserIdByUsername("seth") devuelve 1. +
La lista amistades está vacía. +
Se crea FriendRepository con estos mocks.
| Se invoca GetFriends("seth"). +
Se verifica que la lista resultante está vacía.
| Éxito: si el usuario no tiene amistades, el método devuelve una lista vacía.

| TC-FR-46
| GetFriends_OneFriendshipWhereUserIsUser1_ReturnsFriendDto
| username = "seth" (id=1)
| amistades contiene una entrada donde (id_usuario1 = 1, id_usuario2 = 2) y usuarios1 es el amigo con username "amigo". +
Se invoca GetFriends("seth").
| Se verifica que el resultado tiene exactamente un elemento. +
El IdFriend es 2. +
El Username del amigo es "amigo".
| Éxito: se obtiene correctamente el amigo cuando el usuario es usuario1 en la relación.

| TC-FR-47
| GetFriends_OneFriendshipWhereUserIsUser2_ReturnsFriendDto
| username = "seth" (id=1)
| amistades contiene una entrada donde (id_usuario1 = 3, id_usuario2 = 1) y la navegación usuarios apunta al amigo (id=3, username="otro"). +
Se invoca GetFriends("seth").
| Se verifica que hay un solo amigo en la lista. +
IdFriend = 3. +
Username = "otro".
| Éxito: se obtiene el amigo cuando el usuario es usuario2 en la relación.

| TC-FR-48
| GetFriends_MultipleFriendships_ReturnsAllFriends
| username = "seth" (id=1)
| amistades contiene dos relaciones: (1,2) con amigo "uno" y (3,1) con amigo "dos". +
Se invoca GetFriends("seth").
| Se verifica que el resultado contiene 2 elementos. +
Se comprueba que hay amigos con IDs 2 y 3.
| Éxito: el método devuelve todos los amigos del usuario, sin importar la posición en la relación.

| TC-FR-49
| GetFriends_FriendWithoutProfile_UsesDefaultValues
| username = "seth" (id=1)
| La lista amistades contiene una amistad (1,7) cuyo usuario amigo no tiene perfiles. +
Se invoca GetFriends("seth").
| Se verifica que hay un elemento en la lista. +
IdFriend = 7. +
Username = "N/A" (valor por defecto).
| Éxito: al no haber perfil, se utilizan valores por defecto en el DTO de amigo.

| TC-FR-50
| GetFriendRequests_NoRequests_ReturnsEmptyList
| username = "seth" (id=1)
| solicitudes_amistad está vacía. +
Se crea FriendRepository con el mock de usuarios y contexto. +
Se invoca GetFriendRequests("seth").
| Se verifica que la lista resultante está vacía.
| Éxito: si no hay solicitudes de amistad para el usuario, se devuelve lista vacía.

| TC-FR-51
| GetFriendRequests_OnePendingRequest_ReturnsFriendDto
| username = "seth" (id=1)
| solicitudes_amistad contiene una solicitud (emisor=2, receptor=1, estado="pendiente") con el emisor usuarios que tiene username "amigo". +
Se invoca GetFriendRequests("seth").
| Se verifica que hay un solo elemento en el resultado. +
IdFriend = 2. +
Username = "amigo".
| Éxito: se devuelve correctamente el emisor como solicitud pendiente.

| TC-FR-52
| GetFriendRequests_IgnoresNonPendingRequests
| username = "seth" (id=1)
| solicitudes_amistad tiene solicitudes hacia el usuario, pero con estados "rechazada" y "aceptada". +
Se invoca GetFriendRequests("seth").
| Se verifica que el resultado está vacío.
| Éxito: solo se consideran solicitudes con estado "pendiente".


| TC-FR-53
| GetFriendRequests_MultiplePendingRequests_ReturnsAll
| username = "seth" (id=1)
| solicitudes_amistad contiene dos solicitudes pendientes de usuarios 2 y 3 hacia receptor 1, cada uno con su perfil. +
Se invoca GetFriendRequests("seth").
| Se verifica que la lista tiene 2 elementos. +
Se comprueba que hay solicitudes de amigos con IDs 2 y 3.
| Éxito: se devuelven todas las solicitudes pendientes para el usuario.

| TC-FR-54
| GetFriendRequests_EmitterHasNoProfile_UsesDefaultValues
| username = "seth" (id=1)
| solicitudes_amistad contiene una solicitud pendiente de un usuario (id=5) sin perfiles. +
Se invoca GetFriendRequests("seth").
| Se verifica que el resultado tiene un elemento. +
Se comprueba que Username = "N/A".
| Éxito: si el emisor no tiene perfil, se utiliza un username por defecto en el DTO.

| TC-FR-55
| UpdateBlockStatus_BlockSelf_ThrowsUserValidationError
| blockerUsername = "same", blockedUsername = "same", bloquear = true
| IRepositoryUsers.GetUserIdByUsername("same") devuelve 10 para ambos. +
Se crea FriendRepository con contexto simulado.
| Se invoca UpdateBlockStatus("same","same", true). +
Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se impide que un usuario se bloquee a sí mismo.

| TC-FR-56
| UpdateBlockStatus_Block_AddsBlockEntry
| blockerUsername = "A" (id=1), blockedUsername = "B" (id=2), bloquear = true
| bloqueos, amistades y solicitudes_amistad están vacíos. +
Se configura el contexto para usar esas listas. +
Se invoca UpdateBlockStatus("A","B", true).
| Se verifica que la lista bloqueos queda con exactamente 1 elemento.
| Éxito: se registra el bloqueo entre los dos usuarios.

| TC-FR-57
| UpdateBlockStatus_BlockAlreadyBlocked_ThrowsException
| blockerUsername = "A" (id=1), blockedUsername = "B" (id=2), bloquear = true
| bloqueos ya contiene un registro (1,2). +
amistades y solicitudes_amistad están vacíos. +
Se invoca UpdateBlockStatus("A","B", true).
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: no se puede bloquear a un usuario que ya está bloqueado.

| TC-FR-58
| UpdateBlockStatus_Unblock_RemovesEntry
| blockerUsername = "A" (id=1), blockedUsername = "B" (id=2), bloquear = false
| La lista bloqueos contiene un registro (1,2). +
amistades y solicitudes_amistad se simulan como listas vacías. +
Se invoca UpdateBlockStatus("A","B", false).
| Se verifica que la lista bloqueos queda vacía.
| Éxito: el desbloqueo elimina correctamente el registro.

| TC-FR-59
| UpdateBlockStatus_UnblockMissing_ThrowsException
| blockerUsername = "A" (id=1), blockedUsername = "B" (id=2), bloquear = false
| La lista bloqueos está vacía (no hay bloqueo). +
Se invoca UpdateBlockStatus("A","B", false).
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: no se puede desbloquear a alguien que no está bloqueado.

| TC-FR-60
| DeleteFriend_ValidFriendship_RemovesFriendAndReturnsTrue
| usernames "A" (id=1) y "B" (id=2)
| usuarios contiene usuarios 1 y 2. +
amistades contiene una relación (1,2). +
Se crea FriendRepository con estos datos. +
Se invoca DeleteFriend("A","B").
| Se verifica que el método devuelve true. +
Se comprueba que la lista amistades queda vacía.
| Éxito: se elimina correctamente la amistad y se indica éxito.

| TC-FR-61
| DeleteFriend_NoFriendship_ThrowsFriendsLoadError
| usernames "A" (id=1) y "B" (id=2)
| usuarios contiene 1 y 2. +
amistades está vacía (no son amigos). +
Se invoca DeleteFriend("A","B").
| Se verifica que se lanza RepositoryValidationException con código de amistad (FriendsLoadError implícito).
| Excepción controlada: no se puede eliminar una amistad inexistente.

| TC-FR-62
| DeleteFriend_UserDoesNotExist_ThrowsException
| usernames "A" (id=1) y "B" (id=999 simulado)
| usuarios solo contiene al usuario con id=1. +
El mock de IRepositoryUsers devuelve 999 para "B". +
Se invoca DeleteFriend("A","B").
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: si uno de los usuarios no existe en la tabla usuarios, la operación falla.

| TC-FR-63
| DeleteFriend_FriendshipReverseOrder_RemovesCorrectEntry
| usernames "A" (id=1) y "B" (id=2)
| amistades contiene una relación (2,1) (orden invertido). +
usuarios contiene ambos usuarios. +
Se invoca DeleteFriend("A","B").
| Se comprueba que la lista amistades queda vacía.
| Éxito: se elimina la amistad aunque los IDs estén en el orden inverso.

| TC-FR-64
| DeleteFriend_SaveChanges_IsCalled
| usernames "A" (id=1) y "B" (id=2)
| amistades contiene una amistad (1,2). +
usuarios contiene IDs 1 y 2. +
mockDb.SaveChanges() se marca como verificable. +
Se invoca DeleteFriend("A","B").
| Se verifica que SaveChanges es llamado exactamente una vez.
| Éxito: además de eliminar la amistad, se confirma que se persiste el cambio en la base de datos.

| TC-FR-65
| GetFriendPublicProfile_ValidUserWithProfile_ReturnsCorrectData
| username = "seth" (id=1)
| usuarios contiene un usuario con perfil completo: username "seth", nombre "Seth", apellido "Marquez", URL y avatar. +
participantes_partida contiene dos partidas para el usuario, una con posición 1 y otra con 3. +
Se invoca GetFriendPublicProfile("seth").
| Se verifican todos los campos del resultado: +
Username = "seth". +
Name = "Seth". +
LastName = "Marquez". +
SocialUrl = "http://test.com". +
AvatarFile = "img.png". +
MatchesPlayed = 2. +
Wins = 1. +
Loses = 1.
| Éxito: se construye correctamente el perfil público con estadísticas de partidas.

| TC-FR-66
| GetFriendPublicProfile_UserWithoutProfile_UsesDefaultValues
| username = "user" (id=1)
| usuarios contiene un usuario sin perfiles. +
participantes_partida está vacío. +
Se invoca GetFriendPublicProfile("user").
| Se comprueba que Username, Name, LastName y SocialUrl son cadenas vacías. +
AvatarFile = "avatarIcon.png". +
Las estadísticas (MatchesPlayed, Wins, Loses) son 0.
| Éxito: al no tener perfil ni partidas, se usan valores por defecto y estadísticas en cero.

| TC-FR-67
| GetFriendPublicProfile_UserNotFound_ThrowsException
| username = "ghost" (id=99)
| El mock de repositorio devuelve id=99, pero la lista usuarios está vacía. +
Se invoca GetFriendPublicProfile("ghost").
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: si el usuario no existe en la base de datos, la consulta del perfil público falla con error de validación.

| TC-FR-68
| GetFriendPublicProfile_NoMatches_ShouldReturnZeroStats
| username = "player" (id=1)
| usuarios contiene un usuario con perfil mínimo (solo username). +
participantes_partida está vacío (no ha jugado). +
Se invoca GetFriendPublicProfile("player").
| Se verifica que MatchesPlayed, Wins y Loses son 0.
| Éxito: el método asigna correctamente estadísticas en cero si el jugador no tiene partidas.

| TC-FR-69
| GetFriendPublicProfile_NullAvatar_UsesDefaultAvatar
| username = "pic" (id=1)
| usuarios contiene un perfil con imagen_perfil = null. +
participantes_partida está vacío. +
Se invoca GetFriendPublicProfile("pic").
| Se verifica que AvatarFile es "avatarIcon.png".
| Éxito: cuando el avatar almacenado es nulo, se usa el avatar por defecto.

| TC-FR-70
| DeleteFriendAndBlock_AlreadyBlocked_ThrowsException
| usernames "A" (id=1) y "B" (id=2)
| usuarios contiene 1 y 2. +
amistades está vacía. +
bloqueos ya contiene un registro (1 bloquea a 2). +
Se invoca DeleteFriendAndBlock("A","B").
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: no se puede usar la operación combinada si el usuario ya está bloqueado.

| TC-FR-71
| DeleteFriendAndBlock_SameUser_ThrowsException
| username1 = "A", username2 = "A"
| IRepositoryUsers devuelve id=1 para "A". +
usuarios contiene solo ese usuario. +
Se invoca DeleteFriendAndBlock("A","A").
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: no se permite eliminar amistad y bloquearse a uno mismo.

| TC-FR-72
| DeleteFriendAndBlock_UserNotFound_ThrowsException
| usernames "A" (id=1) y "B" (id=2)
| El repositorio de usuarios devuelve IDs 1 y 2, pero en usuarios solo existe el registro con id=1. +
Se invoca DeleteFriendAndBlock("A","B").
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: si uno de los usuarios no existe en la base de datos, la operación combinada falla.
|===

== RankingRepositoryTests

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-RR-01
| GetTop10Players_NoPlayers_ReturnsEmptyList
| Sin jugadores registrados. +
Listas vacías: participantes_partida y usuarios.
| mockDb.participantes_partida retorna lista vacía. +
mockDb.usuarios retorna lista vacía. +
repo.CreateDbContext() devuelve este contexto simulado.
| Se verifica que la lista resultante esté vacía.
| Éxito: no hay jugadores → ranking vacío.

| TC-RR-02
| GetTop10Players_OnePlayer_ReturnsCorrectStats
| Jugador con id=1 tiene: +
 2 partidas jugadas. +
 1 victoria (posición 1). +
 1 derrota (posición 2). +
Usuario tiene username "seth".
| participantes_partida contiene dos registros del jugador 1. +
usuarios contiene id=1, username="seth". +
Contexto simulado devuelto por CreateDbContext().
| Se valida: +
 Solo un jugador en ranking. +
 Username = "seth". +
 MatchesPlayed = 2. +
 Wins = 1. +
 Loses = 1. +
 WinRate = 0.5.
| Éxito: estadísticas calculadas correctamente.

| TC-RR-03
| GetTop10Players_OrdersCorrectly_ByWinsThenMatches
| Tres jugadores: +
 Jugador 1 → 1 victoria. +
 Jugador 2 → 2 victorias. +
 Jugador 3 → 0 victorias y 3 partidas. +
Se evalúa ordenamiento.
| BD simulada con partidas que generan conteos distintos. +
usuarios contiene nombres: A, B, C para ids 1, 2, 3.
| Se verifica que el ranking quede ordenado como: +
1. B (más wins) +
2. A (2° mejor) +
3. C (sin wins)
| Éxito: ranking ordenado correctamente por victorias y luego por partidas.

| TC-RR-04
| GetTop10Players_ReturnsMax10
| 20 jugadores distintos, todos con una victoria. +
Usernames: player1 … player20.
| BD simulada contiene 20 entradas en ambas tablas. +
CreateDbContext() devuelve este contexto.
| Se valida que solo se retornen los primeros 10 elementos.
| Éxito: ranking limitado a máximo 10 jugadores.
|=== 


== LobbyManager

[cols="1,2,3,3,3,2",options="header"]
|===

| ID Caso
| Nombre / Escenario
| Entradas
| Condiciones de Entrada (Mock Setup)
| Condiciones de Salida (Verificaciones)
| Resultado Esperado

| TC-LM-01
| ValidateCreateRequest_NullRequest_ThrowsException
| request = null
| Ninguna configuración especial.
| Se invoca el método privado ValidateCreateRequest vía reflexión. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código MatchCreationFailed.

| TC-LM-02
| ValidateCreateRequest_InvalidMaxPlayers_ThrowsException
| request.MaxPlayers = 3
| Ninguna configuración especial.
| Se invoca ValidateCreateRequest. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código LobbyInvalidMaxPlayers.

| TC-LM-03
| ValidateJoinRequest_NullRequest_ThrowsException
| request = null
| Ninguna configuración especial.
| Se invoca ValidateJoinRequest. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código LobbyNotFound.

| TC-LM-04
| ValidateJoinRequest_EmptyUsername_ThrowsException
| LobbyCode = 123456, Username = ""
| Ninguna configuración especial.
| Se invoca ValidateJoinRequest. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código UsernameEmpty.

| TC-LM-05
| IsGuest_ValidGuestUsername_ReturnsTrue
| username = "Guest-1234"
| Ninguna configuración especial.
| Se invoca el método privado IsGuest.
| Éxito: el método devuelve true para usernames guest válidos.

| TC-LM-06
| IsGuest_InvalidGuestFormat_ReturnsFalse
| username = "Guest-12A4"
| Ninguna configuración especial.
| Se invoca IsGuest.
| Éxito: el método devuelve false para formatos guest inválidos.

| TC-LM-07
| LobbyState_AddAndRemoveMember_UpdatesCountCorrectly
| username = "Seth"
| Se crea una instancia de LobbyState vía reflexión.
| Se agrega un miembro y luego se elimina. +
Se consulta el contador de miembros.
| Éxito: el conteo pasa de 1 a 0 correctamente.

| TC-LM-08
| LobbyState_AssignNewHost_AssignsOldestMember
| Usuarios = "Ana", "Luis"
| Lobby con host inicial. +
Se agregan miembros en orden.
| Se ejecuta AssignNewHostIfNeeded. +
Se consulta HostUsername.
| Éxito: el host se reasigna al primer miembro agregado.

| TC-LM-09
| LobbyState_ThrowIfFull_WhenMaxPlayersReached_ThrowsException
| MaxPlayers = 1
| Se crea un lobby con capacidad máxima alcanzada.
| Se invoca ThrowIfFull. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código LobbyFull.

| TC-LM-10
| LobbyState_ThrowIfGameStarted_ThrowsException
| N/A
| Se crea un lobby y se marca como iniciado.
| Se invoca ThrowIfGameStarted. +
Se captura la excepción.
| Excepción controlada: se lanza RepositoryValidationException con código LobbyGameAlreadyStarted.

|===

== RepositoryUser

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-RU-01 | ValidateCreateUser_Throws_WhenEmailExists | UserDto con Email = existe@test.com | usuarios contiene un registro con correo duplicado; perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: cuando el correo ya existe en la base de datos, la validación evita la creación de un usuario duplicado.

| TC-RU-02 | ValidateCreateUser_Throws_WhenUsernameExists | UserDto con Username = Seth | usuarios vacío; perfiles contiene username Seth | Se lanza RepositoryValidationException | Excepción controlada: si el username ya está registrado, el sistema impide la creación del perfil.

| TC-RU-03 | ValidateCreateUser_NoConflicts_DoesNotThrow | UserDto válido sin duplicados | usuarios vacío; perfiles vacío; SaveChanges simulado | No se lanza excepción | Éxito: al no existir correo ni username duplicado, la validación permite continuar sin errores.

| TC-RU-04 | CreateUser_ValidUser_AddsUserAndProfile | UserDto con email y username válidos | usuarios y perfiles vacíos; SaveChanges asigna id_usuario=10 | usuarios.Count=1; perfiles.Count=1; correo y username asignados; result.id_usuario=10 | Éxito: el usuario y perfil se crean correctamente, asignando el ID simulado (10) y registrando ambos objetos en la BD.

| TC-RU-05 | CreateUser_ReturnsUserWithProfileLoaded | UserDto válido | usuarios vacío; SaveChanges asigna id_usuario=50 | result no es null; result.id_usuario=50 | Éxito: el usuario se devuelve con el perfil cargado y con ID asignado por la base de datos.

| TC-RU-06 | CreateUser_CallsSaveChangesTwice | UserDto válido | usuarios vacío; perfiles vacío; SaveChanges cuenta llamadas | SaveChanges se ejecuta 2 veces | Éxito: se comprueba que crear usuario y perfil requiere dos llamadas a SaveChanges, confirmando el flujo correcto.

| TC-RU-07 | CreateUser_AssignsCorrectFields | UserDto con correo y password | usuarios vacío; perfiles vacío | correo asignado; password_hash asignado | Éxito: los campos correo y password_hash se asignan correctamente al nuevo usuario.

| TC-RU-08 | Login_ValidCredentials_ReturnsPublicProfile | LoginRequest username=Seth password=1234 | usuarios contiene datos correctos con perfil; perfiles vacío | profile.IdUser=1; profile.Username=Seth; profile.Email=test@mail.com | Éxito: las credenciales son válidas y se genera un perfil público coherente para el usuario.

| TC-RU-09 | Login_UserNotFound_ThrowsException | LoginRequest con usuario inexistente | usuarios vacío; perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: cuando no existe coincidencia por correo/username, el login se rechaza con error de validación.

| TC-RU-10 | Login_IncorrectPassword_ThrowsException | LoginRequest con password incorrecto | usuarios contiene password_hash distinto; perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: si la contraseña no coincide, el sistema protege el acceso negando la autenticación.

| TC-RU-11 | Login_InvalidRequest_ThrowsValidationException | LoginRequest vacío | Sin mocks relevantes | Se lanza RepositoryValidationException | Excepción controlada: no se permite procesar una solicitud de login con campos incompletos o inválidos.

| TC-RU-12 | GetPublicProfile_UserExists_ReturnsPublicProfile | id_usuario=10 | usuarios contiene un usuario con perfil completo | profile.IdUser=10; Username=Seth; Email=test@correo.com | Éxito: se devuelve el perfil público completo del usuario existente.

| TC-RU-13 | GetPublicProfile_UserNotFound_ThrowsException | id_usuario inexistente | usuarios vacío; perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: cuando el ID no corresponde a ningún usuario, el sistema rechaza la consulta del perfil.

| TC-RU-14 | GetPublicProfile_UserExistsButHasNoProfile_ReturnsDefaultProfile | id_usuario=20 | usuarios contiene usuario sin perfiles | Username=N/A; Name=N/A | Éxito: si el usuario existe pero no tiene perfil, se devuelven valores por defecto (“N/A”).

| TC-RU-15 | GetFriendPublicProfile_ValidUsername_ReturnsProfile | Username=Seth | perfiles contiene perfil completo; usuarios contiene correo | result.Username=Seth; result.Name=Seth; result.LastName=Marquez; url correcta | Éxito: el perfil del amigo existe y los datos públicos se devuelven correctamente.

| TC-RU-16 | GetFriendPublicProfile_EmptyUsername_ThrowsUsernameEmpty | Username vacío | Sin BD necesaria | Se lanza RepositoryValidationException | Excepción controlada: no se permite buscar un perfil con username vacío.

| TC-RU-17 | GetFriendPublicProfile_UserNotFound_ThrowsUserProfileNotFound | Username inexistente | perfiles vacío; usuarios vacío | Se lanza RepositoryValidationException | Excepción controlada: si el perfil no existe, la consulta falla de forma segura.

| TC-RU-18 | ChangeUsername_EmptyCurrent_ThrowsUsernameEmpty | current="" new="Nuevo" | Sin BD necesaria | Se lanza RepositoryValidationException | Excepción controlada: no se puede cambiar un username si el actual está vacío.

| TC-RU-19 | ChangeUsername_NewUsernameAlreadyExists_ThrowsUsernameExists | new username ya utilizado | perfiles contiene nuevo nombre | Se lanza RepositoryValidationException | Excepción controlada: el sistema impide cambiar el username por uno que ya está en uso.

| TC-RU-20 | ChangeUsername_CurrentUserNotFound_ThrowsUserProfileNotFound | current inexistente | perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: si el usuario actual no existe, la operación de cambio de username falla.

| TC-RU-21 | ChangeUsername_ValidChange_ReturnsTrue | current="Actual" new="Nuevo" | perfiles contiene usuario Actual; SaveChanges=1 | result=True; username actualizado; SaveChanges una vez | Éxito: el username se actualiza correctamente y se guarda la modificación.

| TC-RU-22 | ChangePassword_InvalidPassword_ThrowsValidationError | username=user password="" | Sin mocks | Se lanza RepositoryValidationException | Excepción controlada: una nueva contraseña vacía o inválida causa error de validación.

| TC-RU-23 | ChangePassword_UserNotFound_ThrowsUserNotFound | username=Seth | usuarios vacío | Se lanza RepositoryValidationException | Excepción controlada: si el usuario no existe, no se permite actualizar la contraseña.

| TC-RU-24 | ChangePassword_ValidChange_ReturnsTrue | username=Seth password=Seth_Dev02 | usuarios contiene usuario; perfiles contiene username en minúscula | password_hash actualizado; SaveChanges=1 | Éxito: la contraseña se cambia correctamente y se confirma mediante SaveChanges.

| TC-RU-25 | GetUserIdByUsername_EmptyUsername_ThrowsUsernameEmpty | username vacío | Sin mocks | Se lanza RepositoryValidationException | Excepción controlada: no se puede buscar un ID con username vacío.

| TC-RU-26 | GetUserIdByUsername_ProfileNotFound_ThrowsUserProfileNotFound | username inexistente | perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: si no existe un perfil asociado al username, la búsqueda falla.

| TC-RU-27 | GetUserIdByUsername_ProfileExists_ReturnsId | username=Seth | perfiles contiene id_usuario=10 | result=10 | Éxito: se devuelve correctamente el ID del usuario asociado al username.

| TC-RU-28 | ChangeAvatar_InvalidId_ThrowsUserNotFound | id_usuario=0 | Sin BD | Se lanza RepositoryValidationException | Excepción controlada: no se puede actualizar un avatar para un ID inválido.

| TC-RU-29 | ChangeAvatar_EmptyAvatar_ThrowsAvatarUpdateFailed | avatar vacío | Sin BD | Se lanza RepositoryValidationException | Excepción controlada: no se permite actualizar avatar con un valor vacío.

| TC-RU-30 | ChangeAvatar_ProfileNotFound_ThrowsUserProfileNotFound | id_usuario=10 avatar=avatar.png | perfiles vacío | Se lanza RepositoryValidationException | Excepción controlada: si el perfil no existe, la actualización del avatar falla.

| TC-RU-31 | ChangeAvatar_ValidUpdate_ReturnsTrue | id_usuario=7 newAvatar.png | perfiles contiene id_usuario=7; SaveChanges simulado | avatar actualizado; SaveChanges una vez | Éxito: el avatar se actualiza y se confirma mediante SaveChanges.

| TC-RU-32 | CreateUsuario_CreatesAndAddsUser | llamada privada mediante reflexión | usuarios vacío | lista usuarios.Count=1; correo asignado | Éxito: el método privado crea y agrega el usuario correctamente.

| TC-RU-33 | CreateUsuario_CallsSaveChanges | llamado privado | usuarios vacío | SaveChanges ejecutado una vez | Éxito: SaveChanges se ejecuta una vez como se espera.

| TC-RU-34 | CreatePerfil_AddsProfile | invocación privada | perfiles vacío | perfiles.Count=1 | Éxito: el perfil es creado y añadido correctamente.

| TC-RU-35 | CreatePerfil_CallsSaveChanges | invocación privada | perfiles vacío | SaveChanges una vez | Éxito: SaveChanges confirma la creación del perfil.

| TC-RU-36 | GetUserWithProfile_ReturnsCorrectUser | id_usuario=9 | usuarios contiene id=9 | result.id_usuario=9 | Éxito: se obtiene correctamente el usuario solicitado mediante el método privado.

| TC-RU-37 | GetPerfilByUsername_Found_ReturnsPerfil | username=Seth | perfiles contiene registro Seth | result.username=Seth | Éxito: el perfil asociado al username se devuelve correctamente.

| TC-RU-38 | FindUserForLogin_ByEmail_ReturnsUser | login con email | usuarios contiene correo mail@test.com | result no null | Éxito: el login por correo encuentra correctamente al usuario.

| TC-RU-39 | FindUserForLogin_ByUsername_ReturnsUser | login con username Seth | usuarios contiene perfiles Seth | result no null | Éxito: el login por username detecta correctamente al usuario.

| TC-RU-40 | SendFriendRequest_ValidRequest_AddsRequestAndReturnsTrue | sender, receiver | usuarios contiene ambos; solicitudes vacío; no amistades ni bloqueos | result=True; solicitudes.Count=1 | Éxito: la solicitud de amistad se registra correctamente y queda en estado pendiente.

| TC-RU-41 | SendFriendRequest_UserDoesNotExist_ThrowsUserNotFound | receiver inexistente | usuarios contiene solo sender | Se lanza RepositoryValidationException | Excepción controlada: si uno de los usuarios no existe en BD, no se puede crear la solicitud.

| TC-RU-42 | SendFriendRequest_AlreadyFriends_ThrowsFriendsLoadError | sender y receiver ya amigos | amistades contiene relación | Se lanza RepositoryValidationException | Excepción controlada: si ya son amigos, no se permite generar una solicitud nueva.

| TC-RU-43 | SendFriendRequest_ReceiverHasBlockedSender_ThrowsFriendsLoadError | receiver bloqueó a sender | bloqueos contiene relación | Se lanza RepositoryValidationException | Excepción controlada: si el receptor ha bloqueado al emisor, la operación falla.

| TC-RU-44 | SendFriendRequest_PendingRequestExists_ThrowsFriendsLoadError | existe solicitud pendiente | solicitudes contiene registro pendiente | Se lanza RepositoryValidationException | Excepción controlada: no se permite duplicar una solicitud ya pendiente.

| TC-RU-45 | UpdateFriendRequestStatus_NoPendingRequest_ThrowsException | aceptar/rechazar inexistente | solicitudes vacío | Se lanza RepositoryValidationException | Excepción controlada: no se puede aceptar/rechazar una solicitud inexistente.

| TC-RU-46 | UpdateFriendRequestStatus_RequestNotPending_ThrowsException | solicitud no pendiente | solicitudes contiene estado rechazado | Se lanza RepositoryValidationException | Excepción controlada: solo solicitudes en estado “pendiente” pueden cambiar de estado.

| TC-RU-47 | UpdateFriendRequestStatus_Accepted_AddsFriendship | aprobar solicitud | solicitudes contiene pendiente; amistades vacío | amistades.Count=1; solicitudes vacía | Éxito: la solicitud se acepta, se crea la amistad y la solicitud se elimina.

| TC-RU-48 | UpdateFriendRequestStatus_Accepted_AlreadyFriends_DoesNotDuplicate | ya son amigos | amistades contiene relación; solicitudes contiene pendiente | amistades sigue con 1; solicitudes vacía | Éxito: si ya son amigos, la aceptación no duplica registros.

| TC-RU-49 | UpdateFriendRequestStatus_AcceptBlocked_ThrowsException | bloqueos existentes | bloqueos contiene registro | Se lanza RepositoryValidationException | Excepción controlada: si existe un bloqueo, no se permite aceptar la solicitud.

| TC-RU-50 | UpdateFriendRequestStatus_Rejected_ChangesState | solicitud rechazada | solicitudes contiene estado pendiente | estado actualizado a rechazado | Éxito: rechazar la solicitud actualiza su estado correctamente.

|===

== RepositorySanctions

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-RS-01
| ApplyBan_PermanentBan_AddsSanctionCorrectly
| userId=10, permanent=true, untilUtc=null, reason="Toxicity"
| Sanciones vacío; Add() agrega nueva sanción; SaveChanges correcto
| sanciones.Count=1; tipo_sancion="permanente"; fecha_fin=null; motivo="Toxicity"; SaveChanges una vez
| Éxito: el baneo permanente se registra correctamente con valores consistentes.

| TC-RS-02
| ApplyBan_TemporaryBan_AssignsCorrectEndDate
| userId=20, permanent=false, untilUtc=fecha futura, reason="AFK"
| Sanciones vacío; SaveChanges correcto
| sanciones.Count=1; tipo_sancion="temporal"; fecha_fin asignada; activo=true
| Éxito: el baneo temporal se registra con fecha de expiración válida.

| TC-RS-03
| ApplyBan_SaveChangesFails_ThrowsException
| userId=1, permanent=false, untilUtc=null, reason="Error test"
| SaveChanges lanza Exception("DB crash")
| Se lanza una excepción
| Excepción controlada: si SaveChanges falla, el repositorio no silencia el error y propaga la excepción.

| TC-RS-04
| HasActiveBan_NoSanctions_ReturnsFalse
| userId=5
| Sanciones vacío
| resultado=False
| Éxito: si no existen sanciones registradas, el usuario no está baneado.

| TC-RS-05
| HasActiveBan_UserHasInactiveSanction_ReturnsFalse
| userId=5
| Sanciones contiene un registro con activo=false
| resultado=False
| Éxito: si la sanción está inactiva, no se considera como baneo vigente.

| TC-RS-06
| HasActiveBan_UserHasExpiredSanction_ReturnsFalse
| userId=7
| fecha_fin < ahora; activo=true
| resultado=False
| Éxito: las sanciones expiradas no son consideradas activas.

| TC-RS-07
| HasActiveBan_UserHasPermanentActiveBan_ReturnsTrue
| userId=3
| Sanciones contiene registro activo con fecha_fin=null
| resultado=True
| Éxito: un baneo permanente siempre cuenta como activo mientras esté marcado como tal.

| TC-RS-08
| HasActiveBan_TemporaryBanNotExpired_ReturnsTrue
| userId=8
| Sanciones contiene registro activo con fecha_fin > ahora
| resultado=True
| Éxito: una sanción temporal vigente genera un baneo activo.

|===

== RepositoryReports
[cols="1,2,3,3,3,2", options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-RR-01
| AddReport_CreatesReportCorrectly
| reporterId=1, reportedId=2, matchId=10, reason="Toxicidad"
| Lista Reportes vacía; DbSet simulado agrega el reporte; SaveChanges retorna 1
| Se agrega exactamente un registro; campos id_usuario_reportador=1, id_usuario_reportado=2, id_partida=10, motivo="Toxicidad", estado="pendiente"; fecha_reporte asignada
| Éxito: el reporte se crea con todos los campos correctos y queda almacenado en la lista simulada.

| TC-RR-02
| AddReport_SaveFails_ThrowsWrappedException
| reporterId=1, reportedId=2, matchId=3, reason="test"
| SaveChanges lanza excepción "DB error"
| Se captura excepción; el mensaje contiene "Report repository error"
| Excepción controlada: si la base de datos falla, el sistema encapsula el error y lo reporta correctamente.

| TC-RR-03
| CountReportsForUser_NoReports_ReturnsZero
| reportedId=5
| Lista Reportes vacía
| Resultado = 0
| Éxito: si no existen reportes contra el usuario, se devuelve cero.

| TC-RR-04
| CountReportsForUser_MultipleReports_ReturnsCorrectCount
| reportedId=7
| Lista con 3 reportes, 2 pertenecen a reportedId=7
| Resultado = 2
| Éxito: el método cuenta correctamente solo los reportes asociados al usuario indicado.

|===



== SERVICES


== UTILITIES

=== DBCONTEXTFACTORY

[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso 
| Nombre / Escenario 
| Entradas 
| Condiciones de Entrada (Mock Setup) 
| Condiciones de Salida (Verificaciones) 
| Resultado Esperado


| TC-DCF-01
| Configure_ReplacesFactory
| Acción: llamar Configure con un delegado válido
| Se recibe un delegado que crea un nuevo damas_chinasEntities; variable local called=false.
| ctx resultante no es null; la variable called=True, indicando que la fábrica personalizada se usó correctamente.
| Éxito: la fábrica interna se reemplaza y el método Create utiliza la nueva implementación.


| TC-DCF-02
| Configure_Throws_WhenNull
| Acción: llamar Configure(null)
| No existe configuración previa especial; el parámetro de entrada es null.
| Se verifica que Configure(null) lanza ArgumentNullException.
| Excepción controlada: el sistema evita establecer una fábrica nula que rompería la creación del contexto.


| TC-DCF-03
| Reset_RestoresDefaultFactory
| Acción: configurar una fábrica personalizada y luego llamar Reset()
| La fábrica personalizada marca customCalled=true cuando es usada; luego Reset() restaura la fábrica original.
| ctx creado no es null; customCalled=False, indicando que la fábrica por defecto fue restaurada.
| Éxito: Reset revierte correctamente cualquier configuración previa y usa la fábrica estándar.


| TC-DCF-04
| Create_UsesConfiguredFactory
| Acción: llamar Create() dos veces después de configurar una fábrica personalizada
| La fábrica personalizada incrementa counter cada vez que se invoca.
| counter=2 después de dos llamadas a Create(); la fábrica configurada es usada ambas veces.
| Éxito: Create invoca exactamente la fábrica configurada y no la fábrica por defecto.


|===

== EmailLanguageMapper
[cols="1,2,3,3,3,2",options="header"]
|===

| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada | Verificaciones | Resultado Esperado

| TC-ELM-01
| FromCultureCode_Null_ReturnsEnglish
| cultureCode = null
| Ninguna configuración especial.
| Se invoca el método con valor nulo.
| Se retorna EmailLanguage.English.

| TC-ELM-02
| FromCultureCode_Empty_ReturnsEnglish
| cultureCode = ""
| Ninguna configuración especial.
| Se invoca el método con cadena vacía.
| Se retorna EmailLanguage.English.

| TC-ELM-03
| FromCultureCode_Spanish_ReturnsSpanish
| cultureCode = "es-MX"
| Ninguna configuración especial.
| Se evalúa el prefijo del código cultural.
| Se retorna EmailLanguage.Spanish.

| TC-ELM-04
| FromCultureCode_Portuguese_ReturnsPortuguese
| cultureCode = "pt-BR"
| Ninguna configuración especial.
| Se detecta prefijo "pt".
| Se retorna EmailLanguage.Portuguese.

| TC-ELM-05
| FromCultureCode_French_ReturnsFrench
| cultureCode = "fr-FR"
| Ninguna configuración especial.
| Se detecta prefijo "fr".
| Se retorna EmailLanguage.French.

| TC-ELM-06
| FromCultureCode_Unknown_ReturnsEnglish
| cultureCode = "de-DE"
| Ninguna configuración especial.
| No coincide con ningún prefijo conocido.
| Se retorna EmailLanguage.English.

|===


== Validator
[cols="1,2,3,3,3,2",options="header"]
|===
| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-V-01
| ValidateName_Empty_ThrowsException
| name = ""
| Ninguna configuración especial; se invoca ValidateName con cadena vacía.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el validador rechaza nombres vacíos y reporta error de validación.

| TC-V-02
| ValidateName_TooShort_ThrowsException
| name = "A"
| Ninguna configuración especial; se invoca ValidateName con longitud menor a la mínima.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el validador detecta nombres demasiado cortos y no permite continuar.

| TC-V-03
| ValidateName_InvalidCharacters_ThrowsException
| name = "Mar!o"
| Ninguna configuración especial; el nombre contiene caracteres no permitidos.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se rechazan nombres con caracteres inválidos para mantener datos limpios.

| TC-V-04
| ValidateName_Valid_DoesNotThrow
| name = "Seth"
| Ninguna configuración especial; el nombre cumple con longitud y caracteres válidos.
| Se verifica que no se lanza ninguna excepción.
| Éxito: el validador acepta nombres válidos y permite continuar el flujo normal.

| TC-V-05
| ValidateUsername_Empty_ThrowsException
| username = ""
| Ninguna configuración especial; se invoca ValidateUsername con cadena vacía.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema no permite nombres de usuario vacíos.

| TC-V-06
| ValidateUsername_TooShort_ThrowsException
| username = "a"
| Ninguna configuración especial; el username tiene longitud menor a la requerida.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se impide registrar usuarios con nombres demasiado cortos.

| TC-V-07
| ValidateUsername_InvalidCharacters_ThrowsException
| username = "seth!!"
| Ninguna configuración especial; el username contiene símbolos no permitidos.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema rechaza nombres de usuario con caracteres inválidos.

| TC-V-08
| ValidateUsername_Valid_DoesNotThrow
| username = "sethMR"
| Ninguna configuración especial; el username cumple las reglas establecidas.
| Se verifica que no se lanza ninguna excepción.
| Éxito: el validador acepta nombres de usuario válidos y no interrumpe el flujo.

| TC-V-09
| ValidatePassword_Empty_ThrowsException
| password = ""
| Ninguna configuración especial; se invoca ValidatePassword con cadena vacía.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se rechazan contraseñas vacías para proteger la seguridad.

| TC-V-10
| ValidatePassword_NoUppercase_ThrowsException
| password = "hola123!"
| Ninguna configuración especial; la contraseña no contiene letras mayúsculas.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el validador exige mayúsculas en la contraseña para mayor robustez.

| TC-V-11
| ValidatePassword_NoLowercase_ThrowsException
| password = "HOLA123!"
| Ninguna configuración especial; la contraseña no contiene letras minúsculas.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema obliga a incluir minúsculas para cumplir las reglas de complejidad.

| TC-V-12
| ValidatePassword_NoDigit_ThrowsException
| password = "HolaMundo!"
| Ninguna configuración especial; la contraseña no contiene dígitos numéricos.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se evita aceptar contraseñas sin números para no debilitar la seguridad.

| TC-V-13
| ValidatePassword_NoSpecial_ThrowsException
| password = "Hola1234"
| Ninguna configuración especial; la contraseña no tiene caracteres especiales.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el validador obliga al uso de caracteres especiales para aumentar la complejidad.

| TC-V-14
| ValidatePassword_Valid_DoesNotThrow
| password = "Hola123!"
| Ninguna configuración especial; la contraseña cumple todas las reglas de complejidad.
| Se verifica que no se lanza ninguna excepción.
| Éxito: se aceptan contraseñas seguras que cumplen todas las políticas definidas.

| TC-V-15
| ValidateEmail_Empty_ThrowsException
| email = ""
| Ninguna configuración especial; se invoca ValidateEmail con cadena vacía.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema no permite correos vacíos como dato de entrada.

| TC-V-16
| ValidateEmail_TooLong_ThrowsException
| email = 'a' repetido (EmailMaxLength + 1) + "@test.com"
| Ninguna configuración especial; el correo supera el tamaño máximo permitido.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se rechazan correos demasiado largos para respetar las restricciones de longitud.

| TC-V-17
| ValidateEmail_InvalidFormat_ThrowsException
| email = "seth@@@com"
| Ninguna configuración especial; el formato del correo es incorrecto.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se bloquean correos con formato inválido para evitar datos corruptos.

| TC-V-18
| ValidateEmail_Valid_DoesNotThrow
| email = "seth@gmail.com"
| Ninguna configuración especial; el correo tiene formato correcto y longitud válida.
| Se verifica que no se lanza ninguna excepción.
| Éxito: se aceptan correos válidos que cumplen con el formato esperado.

| TC-V-19
| ValidateUserDto_Null_ThrowsException
| dto = null
| Ninguna configuración especial; se envía un objeto nulo a ValidateUserDto.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema no acepta objetos de usuario nulos en la validación.

| TC-V-20
| ValidateUserDto_InvalidName_ThrowsException
| dto = { Name="", LastName="Marquez", Email="seth@mail.com", Username="sethMR" }
| Ninguna configuración especial; solo el nombre es inválido.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se bloquea la creación de usuarios con nombre inválido aunque el resto de datos sea correcto.

| TC-V-21
| ValidateUserDto_Valid_DoesNotThrow
| dto = { Name="Seth", LastName="Marquez", Email="seth@mail.com", Username="sethMR" }
| Ninguna configuración especial; todos los campos cumplen las reglas.
| Se verifica que no se lanza ninguna excepción.
| Éxito: se acepta el DTO de usuario completamente válido para continuar el proceso.

| TC-V-22
| ValidateLoginRequest_Null_ThrowsException
| request = null
| Ninguna configuración especial; se pasa solicitud de login nula.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: el sistema no procesa solicitudes de inicio de sesión nulas.

| TC-V-23
| ValidateLoginRequest_EmptyUsername_ThrowsException
| request = { Username="", Password="123" }
| Ninguna configuración especial; solo el username es inválido.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se obliga a proporcionar un nombre de usuario para intentar el login.

| TC-V-24
| ValidateLoginRequest_BadEmail_ThrowsException
| request = { Username="bademail@", Password="123" }
| Ninguna configuración especial; el username con formato de correo es inválido.
| Se verifica que se lanza RepositoryValidationException.
| Excepción controlada: se impide el login con identificadores que no cumplen el formato esperado.

| TC-V-25
| ValidateLoginRequest_Valid_DoesNotThrow
| request = { Username="sethMR", Password="Abc123!" }
| Ninguna configuración especial; username y password cumplen las reglas de validación.
| Se verifica que no se lanza ninguna excepción.
| Éxito: la solicitud de login válida pasa todas las validaciones y puede continuar al flujo de autenticación.

|===

== DbOutageCoordinator
[cols="1,2,3,3,3,2",options="header"]
|===

| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-DBOC-01
| Trip_FirstCall_ExecutesAllActions
| ex = new Exception("DB down")
| el coordinador no ha sido activado previamente.
| Se invoca Trip por primera vez. +
Se verifica que se registra el error. +
Se envía notificación a Telegram. +
Se fuerzan las desconexiones de sesiones activas y sesiones invitadas.
| Éxito: ante la primera detección de caída de base de datos, el sistema notifica y desconecta correctamente a todos los clientes.

| TC-DBOC-02
| Trip_CalledTwice_OnlyExecutesOnce
| ex = new Exception("DB down")
| El método Trip se invoca dos veces consecutivas sin reiniciar el estado interno.
| Se verifica que la notificación (Telegram) solo se envía una vez.
| Éxito: el coordinador evita ejecutar acciones duplicadas ante múltiples detecciones de la misma caída.

| TC-DBOC-03
| Trip_WhenTelegramThrows_DoesNotThrow
| ex = new Exception("DB down")
| Ninguna configuración especial; 
| Se invoca Trip. +
Se verifica que no se propaga ninguna excepción al exterior.
| Excepción controlada: una falla en el servicio de notificaciones no interrumpe el manejo de la caída de base de datos.

| TC-DDBOCB-04
| Trip_WhenDisconnectSessionsThrows_DoesNotThrow
| ex = new Exception("DB down")
| Ninguna configuración especial; 
| Se invoca Trip. +
Se verifica que el método no lanza excepciones.
| Excepción controlada: errores al desconectar sesiones no afectan la estabilidad del coordinador.

| TC-DBOC-05
| Trip_WhenInnerExceptionOccurs_LogsError
| ex = new Exception("DB down")
| El envío a Telegram lanza una excepción interna simulada.
| Se invoca Trip. +
Se verifica que el error interno es registrado mediante el logger.
| Excepción controlada: los errores internos durante el manejo de la caída son capturados y registrados correctamente.

|===

== RepositoryMatches
[cols="1,2,3,3,3,2",options="header"]
|===

| ID Caso | Nombre / Escenario | Entradas | Condiciones de Entrada (Mock Setup) | Condiciones de Salida (Verificaciones) | Resultado Esperado

| TC-RM-01
| SaveMatchResult_UserColorMapNull_ThrowsArgumentException
| userColorMap = null, winnerUsername = "Seth"
| Ninguna configuración especial; 
| Se invoca SaveMatchResult con userColorMap nulo. +
Se captura la excepción.
| Excepción controlada: se lanza ArgumentException indicando que userColorMap no puede ser nulo.

| TC-RM-02
| SaveMatchResult_UserColorMapEmpty_ThrowsArgumentException
| userColorMap = {}, winnerUsername = "Seth"
| Ninguna configuración especial; 
| Se invoca SaveMatchResult con un diccionario vacío. +
Se captura la excepción.
| Excepción controlada: se lanza ArgumentException cuando no hay jugadores registrados.

| TC-RM-03
| SaveMatchResult_WinnerUsernameNull_ThrowsArgumentException
| userColorMap con un jugador, winnerUsername = null
| El contexto no requiere configuración especial.
| Se invoca SaveMatchResult con winnerUsername nulo. +
Se valida el parámetro de la excepción.
| Excepción controlada: se lanza ArgumentException por nombre de ganador inválido.

| TC-RM-04
| SaveMatchResult_WinnerUsernameEmpty_ThrowsArgumentException
| userColorMap con un jugador, winnerUsername = ""
| El repositorio se ejecuta con un contexto mockeado.
| Se invoca el método con nombre de ganador vacío. +
Se captura la excepción.
| Excepción controlada: se evita registrar partidas sin ganador válido.

| TC-RM-05
| SaveMatchResult_ProfileNotFound_ThrowsUserProfileNotFound
| userColorMap = { "Seth" }, winnerUsername = "Seth"
| perfiles está vacío. +
partidas y participantes_partida están inicializados.
| Se ejecuta SaveMatchResult. +
Se lanza RepositoryValidationException.
| Excepción controlada: si no existe el perfil del jugador, se lanza UserProfileNotFound.

| TC-RM-06
| SaveMatchResult_ValidInput_CreatesMatchAndParticipants
| userColorMap = { "Seth", "Ana" }, winnerUsername = "Seth"
| perfiles contiene ambos usuarios. +
Listas de partidas y participantes_partida inicializadas.
| Se ejecuta el método correctamente. +
Se verifica que se crean dos participantes.
| Éxito: se registra la partida y se guardan los participantes correctamente.

| TC-RM-07
| SaveMatchResult_WinnerAssignedPositionOne
| userColorMap con dos jugadores, winnerUsername = "Seth"
| perfiles contiene ambos usuarios. +
participantes_partida es una lista vacía inicial.
| Se ejecuta SaveMatchResult. +
Se valida que el ganador tenga posicion_final = 1.
| Éxito: el ganador de la partida siempre queda registrado en la primera posición.

| TC-RM-08
| SaveMatchResult_FirstSaveChangesFails_ThrowsDatabaseUnavailable
| userColorMap válido, winnerUsername válido
| Ninguna configuración especial; 
| Se invoca SaveMatchResult. +
Se captura la excepción del repositorio.
| Excepción controlada: fallo inicial de persistencia se traduce en DatabaseUnavailable.

| TC-RM-09
| SaveMatchResult_SecondSaveChangesFails_ThrowsDatabaseUnavailable
| userColorMap válido, winnerUsername válido
| Ninguna configuración especial; 
| Se ejecuta el método completo hasta el segundo guardado. +
Se captura la excepción.
| Excepción controlada: errores posteriores de base de datos también se encapsulan como DatabaseUnavailable.

| TC-RM-10
| SaveMatchResult_SaveChangesValidationFails_ThrowsUnknownError
| userColorMap válido, winnerUsername válido
| Ninguna configuración especial; 
| Se ejecuta SaveMatchResult. +
Se captura RepositoryValidationException.
| Excepción controlada: errores de validación de entidad se reportan como UnknownError.

|===
